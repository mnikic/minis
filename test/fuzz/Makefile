# Compiler must be clang for libFuzzer
CC = clang

# Flags:
# -g: Add debug symbols (crucial for reading stack traces on crash)
# -O1: Optimization level 1 is the sweet spot for fuzzing (fast, but stack traces are still readable)
# -fsanitize=fuzzer,address,undefined: The magic trio (Fuzz engine + Memory safety + Undefined behavior)
CFLAGS = -g -O1 -fsanitize=fuzzer,address,undefined

# Include path to the root source directory
INCLUDES = -I ../../src

# Source files (Relative to test/fuzz/)
SRC_DIR = ../../src
SOURCES = fuzz_parser.c \
          $(SRC_DIR)/io/proto_parser.c \
          $(SRC_DIR)/common/common.c
OUT_SOURCES = fuzz_out.c \
              $(SRC_DIR)/io/out.c \
              $(SRC_DIR)/io/buffer.c \
              $(SRC_DIR)/common/common.c 

OUT_TARGET = out_fuzzer

TARGET = parser_fuzzer
DICT = dict.txt

.PHONY: all clean run

all: $(TARGET)

$(TARGET): $(SOURCES)
	$(CC) $(CFLAGS) $(INCLUDES) -o $@ $^

# "make run" builds and starts the fuzzer immediately
run: $(TARGET)
	@echo "Starting Fuzzer... Press Ctrl+C to stop."
	./$(TARGET) -dict=$(DICT)

$(OUT_TARGET): $(OUT_SOURCES)
	$(CC) $(CFLAGS) $(INCLUDES) -o $@ $^

run_out: $(OUT_TARGET)
	@echo "Fuzzing Output Module..."
	./$(OUT_TARGET)

# Helper to resume fuzzing from a crash file (e.g., make debug CRASH=crash-sha1...)
debug: $(TARGET)
	./$(TARGET) $(CRASH)

clean:
	rm -f $(TARGET) $(OUT_TARGET)
	# Remove artifacts generated by libFuzzer on crash/exit
	rm -f crash-* leak-* timeout-*
